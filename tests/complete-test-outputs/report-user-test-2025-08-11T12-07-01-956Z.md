# n8n Workflow Builder Test Report

**Test Name:** User Test
**Timestamp:** 2025-08-11T12:06:01.515Z
**Duration:** 60440ms
**Success:** ❌ No

## User Prompt
```
Design a workflow triggered by new social media posts that uses AI to analyze content for inappropriate material, automatically flags suspicious content, generates summary reports, stores results in a database, and sends daily digest emails to moderators with statistics and flagged items.
```

## Session ID: `complete_e2e_user_test_1754913961515`

## ========== DISCOVERY PHASE ==========

**Status:** ✅ Success
**Duration:** 23774ms
**Memory Delta:** -4MB

### Logs
```
2025-08-11T12:06:02.000Z [INFO] [Orchestrator] Starting discovery phase
2025-08-11T12:06:02.000Z [DEBUG] [Claude] Sending request for discovery phase
2025-08-11T12:06:17.256Z [INFO] [MCP] Calling tool: get_node_for_task
2025-08-11T12:06:17.256Z [DEBUG] [MCP] Parameters: {"task":"process_webhook_data"}
2025-08-11T12:06:17.256Z [INFO] [MCP] Calling tool: get_node_for_task
2025-08-11T12:06:17.256Z [DEBUG] [MCP] Parameters: {"task":"chat_with_ai"}
2025-08-11T12:06:17.256Z [INFO] [MCP] Calling tool: get_node_for_task
2025-08-11T12:06:17.256Z [DEBUG] [MCP] Parameters: {"task":"insert_postgres_data"}
2025-08-11T12:06:17.256Z [INFO] [MCP] Calling tool: get_node_for_task
2025-08-11T12:06:17.256Z [DEBUG] [MCP] Parameters: {"task":"transform_data"}
2025-08-11T12:06:17.256Z [INFO] [MCP] Calling tool: get_node_for_task
2025-08-11T12:06:17.256Z [DEBUG] [MCP] Parameters: {"task":"send_email"}
2025-08-11T12:06:17.413Z [DEBUG] [MCP] Tool get_node_for_task completed successfully
2025-08-11T12:06:17.424Z [DEBUG] [MCP] Tool get_node_for_task completed successfully
2025-08-11T12:06:17.426Z [DEBUG] [MCP] Tool get_node_for_task completed successfully
2025-08-11T12:06:17.450Z [DEBUG] [MCP] Tool get_node_for_task completed successfully
2025-08-11T12:06:17.799Z [DEBUG] [MCP] Tool get_node_for_task completed successfully
2025-08-11T12:06:17.801Z [INFO] [MCP] Calling tool: search_nodes
2025-08-11T12:06:17.801Z [DEBUG] [MCP] Parameters: {"query":"twitter","limit":20}
2025-08-11T12:06:17.801Z [INFO] [MCP] Calling tool: search_nodes
2025-08-11T12:06:17.801Z [DEBUG] [MCP] Parameters: {"query":"if","limit":20}
2025-08-11T12:06:17.801Z [INFO] [MCP] Calling tool: search_nodes
2025-08-11T12:06:17.801Z [DEBUG] [MCP] Parameters: {"query":"schedule","limit":20}
2025-08-11T12:06:17.911Z [DEBUG] [MCP] Tool search_nodes completed successfully
2025-08-11T12:06:17.937Z [DEBUG] [MCP] Tool search_nodes completed successfully
2025-08-11T12:06:17.964Z [DEBUG] [MCP] Tool search_nodes completed successfully
2025-08-11T12:06:25.678Z [INFO] [Tools] Added node: nodes-base.code (Transform data structure using JavaScript)
2025-08-11T12:06:25.678Z [INFO] [Tools] Added node: nodes-base.openAi (Send a message to an AI model and get response)
2025-08-11T12:06:25.678Z [INFO] [Tools] Added node: nodes-base.emailSend (Send an email notification)
2025-08-11T12:06:25.678Z [INFO] [Tools] Added node: nodes-base.code (Process incoming webhook data with Code node (shows correct data access))
2025-08-11T12:06:25.678Z [INFO] [Tools] Added node: nodes-base.postgres (Insert data into PostgreSQL table)
2025-08-11T12:06:25.678Z [INFO] [Tools] Added node: nodes-base.scheduleTrigger (Triggers daily execution for digest email generation)
2025-08-11T12:06:25.678Z [INFO] [Tools] Added node: nodes-base.if (Routes content based on AI analysis results for conditional flagging)
2025-08-11T12:06:25.678Z [INFO] [Tools] Added node: nodes-base.twitter (Monitors social media posts as trigger source for content analysis)
2025-08-11T12:06:25.773Z [DEBUG] [Orchestrator] Session state updated
2025-08-11T12:06:25.773Z [INFO] [Orchestrator] Data flow captured: 3 transformations
```

### Nodes
- **nodes-base.code** (ID: task_node_4)
  - Purpose: Transform data structure using JavaScript
- **nodes-base.openAi** (ID: task_node_2)
  - Purpose: Send a message to an AI model and get response
- **nodes-base.emailSend** (ID: task_node_5)
  - Purpose: Send an email notification
- **nodes-base.code** (ID: task_node_1)
  - Purpose: Process incoming webhook data with Code node (shows correct data access)
- **nodes-base.postgres** (ID: task_node_3)
  - Purpose: Insert data into PostgreSQL table
- **nodes-base.scheduleTrigger** (ID: search_node_1)
  - Purpose: Triggers daily execution for digest email generation
- **nodes-base.if** (ID: search_node_2)
  - Purpose: Routes content based on AI analysis results for conditional flagging
- **nodes-base.twitter** (ID: search_node_3)
  - Purpose: Monitors social media posts as trigger source for content analysis

### Data Flow
**Input:**
```json
{
  "prompt": "Design a workflow triggered by new social media posts that uses AI to analyze content for inappropriate material, automatically flags suspicious content, generates summary reports, stores results in a database, and sends daily digest emails to moderators with statistics and flagged items."
}
```

**Output:**
```json
{
  "nodes": [
    {
      "id": "task_node_4",
      "type": "nodes-base.code",
      "displayName": "transform data",
      "purpose": "Transform data structure using JavaScript",
      "isPreConfigured": true,
      "config": {
        "language": "javaScript",
        "jsCode": "// Transform each item\nconst results = [];\n\nfor (const item of items) {\n  results.push({\n    json: {\n      // Transform your data here\n      id: item.json.id,\n      processedAt: new Date().toISOString()\n    }\n  });\n}\n\nreturn results;"
      }
    },
    {
      "id": "task_node_2",
      "type": "nodes-base.openAi",
      "displayName": "chat with ai",
      "purpose": "Send a message to an AI model and get response",
      "isPreConfigured": true,
      "config": {
        "resource": "chat",
        "operation": "message",
        "modelId": "gpt-3.5-turbo",
        "messages": {
          "values": [
            {
              "role": "user",
              "content": ""
            }
          ]
        },
        "onError": "continueRegularOutput",
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "alwaysOutputData": true
      }
    },
    {
      "id": "task_node_5",
      "type": "nodes-base.emailSend",
      "displayName": "send email",
      "purpose": "Send an email notification",
      "isPreConfigured": true,
      "config": {
        "fromEmail": "",
        "toEmail": "",
        "subject": "",
        "text": "",
        "onError": "continueRegularOutput",
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 3000,
        "alwaysOutputData": true
      }
    },
    {
      "id": "task_node_1",
      "type": "nodes-base.code",
      "displayName": "process webhook data",
      "purpose": "Process incoming webhook data with Code node (shows correct data access)",
      "isPreConfigured": true,
      "config": {
        "language": "javaScript",
        "jsCode": "// ⚠️ CRITICAL: Webhook data is nested under 'body' property!\n// Connect this Code node after a Webhook node\n\n// Access webhook payload data - it's under .body, not directly under .json\nconst webhookData = items[0].json.body;  // ✅ CORRECT\nconst headers = items[0].json.headers;   // HTTP headers\nconst query = items[0].json.query;       // Query parameters\n\n// Common mistake to avoid:\n// const command = items[0].json.testCommand;  // ❌ WRONG - will be undefined!\n// const command = items[0].json.body.testCommand;  // ✅ CORRECT\n\n// Process the webhook data\ntry {\n  // Validate required fields\n  if (!webhookData.command) {\n    throw new Error('Missing required field: command');\n  }\n  \n  // Process based on command\n  let result = {};\n  switch (webhookData.command) {\n    case 'process':\n      result = {\n        status: 'processed',\n        data: webhookData.data,\n        processedAt: DateTime.now().toISO()\n      };\n      break;\n      \n    case 'validate':\n      result = {\n        status: 'validated',\n        isValid: true,\n        validatedFields: Object.keys(webhookData.data || {})\n      };\n      break;\n      \n    default:\n      result = {\n        status: 'unknown_command',\n        command: webhookData.command\n      };\n  }\n  \n  // Return processed data\n  return [{\n    json: {\n      ...result,\n      requestId: headers['x-request-id'] || crypto.randomUUID(),\n      source: query.source || 'webhook',\n      originalCommand: webhookData.command,\n      metadata: {\n        httpMethod: items[0].json.httpMethod,\n        webhookPath: items[0].json.webhookPath,\n        timestamp: DateTime.now().toISO()\n      }\n    }\n  }];\n  \n} catch (error) {\n  // Return error response\n  return [{\n    json: {\n      status: 'error',\n      error: error.message,\n      timestamp: DateTime.now().toISO()\n    }\n  }];\n}",
        "onError": "continueRegularOutput"
      }
    },
    {
      "id": "task_node_3",
      "type": "nodes-base.postgres",
      "displayName": "insert postgres data",
      "purpose": "Insert data into PostgreSQL table",
      "isPreConfigured": true,
      "config": {
        "operation": "insert",
        "table": "",
        "columns": "",
        "returnFields": "*",
        "onError": "stopWorkflow",
        "retryOnFail": true,
        "maxTries": 2,
        "waitBetweenTries": 1000
      }
    },
    {
      "id": "search_node_1",
      "type": "nodes-base.scheduleTrigger",
      "displayName": "nodes-base.scheduleTrigger",
      "purpose": "Triggers daily execution for digest email generation",
      "needsConfiguration": true
    },
    {
      "id": "search_node_2",
      "type": "nodes-base.if",
      "displayName": "nodes-base.if",
      "purpose": "Routes content based on AI analysis results for conditional flagging",
      "needsConfiguration": true
    },
    {
      "id": "search_node_3",
      "type": "nodes-base.twitter",
      "displayName": "nodes-base.twitter",
      "purpose": "Monitors social media posts as trigger source for content analysis",
      "needsConfiguration": true
    }
  ]
}
```

**Transformations:**
- Intent Analysis
- Node Discovery
- Selection

### Session State (Baseline)
```json
{
  "sessionId": "complete_e2e_user_test_1754913961515",
  "createdAt": "2025-08-11T12:06:02.018Z",
  "state": {
    "phase": "configuration",
    "userPrompt": "Design a workflow triggered by new social media posts that uses AI to analyze content for inappropriate material, automatically flags suspicious content, generates summary reports, stores results in a database, and sends daily digest emails to moderators with statistics and flagged items.",
    "discovered": [
      {
        "id": "task_node_4",
        "type": "nodes-base.code",
        "config": {
          "jsCode": "// Transform each item\nconst results = [];\n\nfor (const item of items) {\n  results.push({\n    json: {\n      // Transform your data here\n      id: item.json.id,\n      processedAt: new Date().toISOString()\n    }\n  });\n}\n\nreturn results;",
          "language": "javaScript"
        },
        "purpose": "Transform data structure using JavaScript",
        "displayName": "transform data",
        "isPreConfigured": true
      },
      {
        "id": "task_node_2",
        "type": "nodes-base.openAi",
        "config": {
          "modelId": "gpt-3.5-turbo",
          "onError": "continueRegularOutput",
          "maxTries": 3,
          "messages": {
            "values": [
              {
                "role": "user",
                "content": ""
              }
            ]
          },
          "resource": "chat",
          "operation": "message",
          "retryOnFail": true,
          "alwaysOutputData": true,
          "waitBetweenTries": 5000
        },
        "purpose": "Send a message to an AI model and get response",
        "displayName": "chat with ai",
        "isPreConfigured": true
      },
      {
        "id": "task_node_5",
        "type": "nodes-base.emailSend",
        "config": {
          "text": "",
          "onError": "continueRegularOutput",
          "subject": "",
          "toEmail": "",
          "maxTries": 3,
          "fromEmail": "",
          "retryOnFail": true,
          "alwaysOutputData": true,
          "waitBetweenTries": 3000
        },
        "purpose": "Send an email notification",
        "displayName": "send email",
        "isPreConfigured": true
      },
      {
        "id": "task_node_1",
        "type": "nodes-base.code",
        "config": {
          "jsCode": "// ⚠️ CRITICAL: Webhook data is nested under 'body' property!\n// Connect this Code node after a Webhook node\n\n// Access webhook payload data - it's under .body, not directly under .json\nconst webhookData = items[0].json.body;  // ✅ CORRECT\nconst headers = items[0].json.headers;   // HTTP headers\nconst query = items[0].json.query;       // Query parameters\n\n// Common mistake to avoid:\n// const command = items[0].json.testCommand;  // ❌ WRONG - will be undefined!\n// const command = items[0].json.body.testCommand;  // ✅ CORRECT\n\n// Process the webhook data\ntry {\n  // Validate required fields\n  if (!webhookData.command) {\n    throw new Error('Missing required field: command');\n  }\n  \n  // Process based on command\n  let result = {};\n  switch (webhookData.command) {\n    case 'process':\n      result = {\n        status: 'processed',\n        data: webhookData.data,\n        processedAt: DateTime.now().toISO()\n      };\n      break;\n      \n    case 'validate':\n      result = {\n        status: 'validated',\n        isValid: true,\n        validatedFields: Object.keys(webhookData.data || {})\n      };\n      break;\n      \n    default:\n      result = {\n        status: 'unknown_command',\n        command: webhookData.command\n      };\n  }\n  \n  // Return processed data\n  return [{\n    json: {\n      ...result,\n      requestId: headers['x-request-id'] || crypto.randomUUID(),\n      source: query.source || 'webhook',\n      originalCommand: webhookData.command,\n      metadata: {\n        httpMethod: items[0].json.httpMethod,\n        webhookPath: items[0].json.webhookPath,\n        timestamp: DateTime.now().toISO()\n      }\n    }\n  }];\n  \n} catch (error) {\n  // Return error response\n  return [{\n    json: {\n      status: 'error',\n      error: error.message,\n      timestamp: DateTime.now().toISO()\n    }\n  }];\n}",
          "onError": "continueRegularOutput",
          "language": "javaScript"
        },
        "purpose": "Process incoming webhook data with Code node (shows correct data access)",
        "displayName": "process webhook data",
        "isPreConfigured": true
      },
      {
        "id": "task_node_3",
        "type": "nodes-base.postgres",
        "config": {
          "table": "",
          "columns": "",
          "onError": "stopWorkflow",
          "maxTries": 2,
          "operation": "insert",
          "retryOnFail": true,
          "returnFields": "*",
          "waitBetweenTries": 1000
        },
        "purpose": "Insert data into PostgreSQL table",
        "displayName": "insert postgres data",
        "isPreConfigured": true
      },
      {
        "id": "search_node_1",
        "type": "nodes-base.scheduleTrigger",
        "purpose": "Triggers daily execution for digest email generation"
      },
      {
        "id": "search_node_2",
        "type": "nodes-base.if",
        "purpose": "Routes content based on AI analysis results for conditional flagging"
      },
      {
        "id": "search_node_3",
        "type": "nodes-base.twitter",
        "purpose": "Monitors social media posts as trigger source for content analysis"
      }
    ],
    "selected": [
      "task_node_4",
      "task_node_2",
      "task_node_5",
      "task_node_1",
      "task_node_3",
      "search_node_1",
      "search_node_2",
      "search_node_3"
    ],
    "configured": {},
    "validated": {},
    "workflow": {
      "nodes": [],
      "settings": {},
      "connections": {}
    },
    "buildPhases": [],
    "operationHistory": [
      {
        "node": {
          "id": "task_node_4",
          "type": "nodes-base.code",
          "config": {
            "jsCode": "// Transform each item\nconst results = [];\n\nfor (const item of items) {\n  results.push({\n    json: {\n      // Transform your data here\n      id: item.json.id,\n      processedAt: new Date().toISOString()\n    }\n  });\n}\n\nreturn results;",
            "language": "javaScript"
          },
          "purpose": "Transform data structure using JavaScript",
          "displayName": "transform data",
          "isPreConfigured": true
        },
        "type": "discoverNode",
        "timestamp": "2025-08-11T12:06:24.990Z"
      },
      {
        "type": "selectNode",
        "nodeId": "task_node_4",
        "timestamp": "2025-08-11T12:06:24.990Z"
      },
      {
        "node": {
          "id": "task_node_2",
          "type": "nodes-base.openAi",
          "config": {
            "modelId": "gpt-3.5-turbo",
            "onError": "continueRegularOutput",
            "maxTries": 3,
            "messages": {
              "values": [
                {
                  "role": "user",
                  "content": ""
                }
              ]
            },
            "resource": "chat",
            "operation": "message",
            "retryOnFail": true,
            "alwaysOutputData": true,
            "waitBetweenTries": 5000
          },
          "purpose": "Send a message to an AI model and get response",
          "displayName": "chat with ai",
          "isPreConfigured": true
        },
        "type": "discoverNode",
        "timestamp": "2025-08-11T12:06:24.990Z"
      },
      {
        "type": "selectNode",
        "nodeId": "task_node_2",
        "timestamp": "2025-08-11T12:06:24.991Z"
      },
      {
        "node": {
          "id": "task_node_5",
          "type": "nodes-base.emailSend",
          "config": {
            "text": "",
            "onError": "continueRegularOutput",
            "subject": "",
            "toEmail": "",
            "maxTries": 3,
            "fromEmail": "",
            "retryOnFail": true,
            "alwaysOutputData": true,
            "waitBetweenTries": 3000
          },
          "purpose": "Send an email notification",
          "displayName": "send email",
          "isPreConfigured": true
        },
        "type": "discoverNode",
        "timestamp": "2025-08-11T12:06:24.991Z"
      },
      {
        "type": "selectNode",
        "nodeId": "task_node_5",
        "timestamp": "2025-08-11T12:06:24.991Z"
      },
      {
        "node": {
          "id": "task_node_1",
          "type": "nodes-base.code",
          "config": {
            "jsCode": "// ⚠️ CRITICAL: Webhook data is nested under 'body' property!\n// Connect this Code node after a Webhook node\n\n// Access webhook payload data - it's under .body, not directly under .json\nconst webhookData = items[0].json.body;  // ✅ CORRECT\nconst headers = items[0].json.headers;   // HTTP headers\nconst query = items[0].json.query;       // Query parameters\n\n// Common mistake to avoid:\n// const command = items[0].json.testCommand;  // ❌ WRONG - will be undefined!\n// const command = items[0].json.body.testCommand;  // ✅ CORRECT\n\n// Process the webhook data\ntry {\n  // Validate required fields\n  if (!webhookData.command) {\n    throw new Error('Missing required field: command');\n  }\n  \n  // Process based on command\n  let result = {};\n  switch (webhookData.command) {\n    case 'process':\n      result = {\n        status: 'processed',\n        data: webhookData.data,\n        processedAt: DateTime.now().toISO()\n      };\n      break;\n      \n    case 'validate':\n      result = {\n        status: 'validated',\n        isValid: true,\n        validatedFields: Object.keys(webhookData.data || {})\n      };\n      break;\n      \n    default:\n      result = {\n        status: 'unknown_command',\n        command: webhookData.command\n      };\n  }\n  \n  // Return processed data\n  return [{\n    json: {\n      ...result,\n      requestId: headers['x-request-id'] || crypto.randomUUID(),\n      source: query.source || 'webhook',\n      originalCommand: webhookData.command,\n      metadata: {\n        httpMethod: items[0].json.httpMethod,\n        webhookPath: items[0].json.webhookPath,\n        timestamp: DateTime.now().toISO()\n      }\n    }\n  }];\n  \n} catch (error) {\n  // Return error response\n  return [{\n    json: {\n      status: 'error',\n      error: error.message,\n      timestamp: DateTime.now().toISO()\n    }\n  }];\n}",
            "onError": "continueRegularOutput",
            "language": "javaScript"
          },
          "purpose": "Process incoming webhook data with Code node (shows correct data access)",
          "displayName": "process webhook data",
          "isPreConfigured": true
        },
        "type": "discoverNode",
        "timestamp": "2025-08-11T12:06:24.991Z"
      },
      {
        "type": "selectNode",
        "nodeId": "task_node_1",
        "timestamp": "2025-08-11T12:06:24.991Z"
      },
      {
        "node": {
          "id": "task_node_3",
          "type": "nodes-base.postgres",
          "config": {
            "table": "",
            "columns": "",
            "onError": "stopWorkflow",
            "maxTries": 2,
            "operation": "insert",
            "retryOnFail": true,
            "returnFields": "*",
            "waitBetweenTries": 1000
          },
          "purpose": "Insert data into PostgreSQL table",
          "displayName": "insert postgres data",
          "isPreConfigured": true
        },
        "type": "discoverNode",
        "timestamp": "2025-08-11T12:06:24.991Z"
      },
      {
        "type": "selectNode",
        "nodeId": "task_node_3",
        "timestamp": "2025-08-11T12:06:24.991Z"
      },
      {
        "node": {
          "id": "search_node_1",
          "type": "nodes-base.scheduleTrigger",
          "purpose": "Triggers daily execution for digest email generation"
        },
        "type": "discoverNode",
        "timestamp": "2025-08-11T12:06:25.170Z"
      },
      {
        "type": "selectNode",
        "nodeId": "search_node_1",
        "timestamp": "2025-08-11T12:06:25.170Z"
      },
      {
        "node": {
          "id": "search_node_2",
          "type": "nodes-base.if",
          "purpose": "Routes content based on AI analysis results for conditional flagging"
        },
        "type": "discoverNode",
        "timestamp": "2025-08-11T12:06:25.170Z"
      },
      {
        "type": "selectNode",
        "nodeId": "search_node_2",
        "timestamp": "2025-08-11T12:06:25.170Z"
      },
      {
        "node": {
          "id": "search_node_3",
          "type": "nodes-base.twitter",
          "purpose": "Monitors social media posts as trigger source for content analysis"
        },
        "type": "discoverNode",
        "timestamp": "2025-08-11T12:06:25.170Z"
      },
      {
        "type": "selectNode",
        "nodeId": "search_node_3",
        "timestamp": "2025-08-11T12:06:25.170Z"
      },
      {
        "type": "completePhase",
        "phase": "discovery",
        "timestamp": "2025-08-11T12:06:25.170Z"
      }
    ],
    "pendingClarifications": [],
    "clarificationHistory": []
  }
}
```

## ========== CONFIGURATION PHASE ==========

**Status:** ❌ Failed
**Duration:** 36181ms
**Memory Delta:** 3MB

### Logs
```
2025-08-11T12:06:25.774Z [INFO] [Orchestrator] Starting configuration phase
2025-08-11T12:06:25.774Z [DEBUG] [Claude] Sending request for configuration phase
2025-08-11T12:06:35.962Z [INFO] [MCP] Calling tool: validate_node_minimal
2025-08-11T12:06:35.962Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.openAi","config":{"modelId":"gpt-4","messages":{"values":[{"role":"system","content":"You are a content moderation AI. Analyze social media posts for inappropriate content including hate speech, harassment, spam, adult content, violence, and misinformation. Respond with a JSON object containing: {\"flagged\": boolean, \"confidence\": number (0-1), \"categories\": [array of violation types], \"severity\": \"low\"|\"medium\"|\"high\", \"summary\": \"brief explanation\"}"},{"role":"user","content":"Please analyze this social media post for inappropriate content:\n\nPost Content: {{$json.content}}\nAuthor: {{$json.author}}\nPlatform: {{$json.platform}}\nPost ID: {{$json.post_id}}"}]},"resource":"chat","operation":"message","options":{"temperature":0.1,"maxTokens":500}}}
2025-08-11T12:06:36.115Z [DEBUG] [MCP] Tool validate_node_minimal completed successfully
2025-08-11T12:06:36.943Z [INFO] [MCP] Calling tool: validate_node_minimal
2025-08-11T12:06:36.943Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.emailSend","config":{"text":"Daily Content Moderation Summary\n\nDate: {{$now.format('YYYY-MM-DD')}}\n\nStatistics:\n- Total posts analyzed: {{$json.totalPosts}}\n- Flagged items: {{$json.flaggedCount}}\n- Approval rate: {{$json.approvalRate}}%\n\nFlagged Content Summary:\n{{$json.flaggedItemsSummary}}\n\nHigh Priority Items:\n{{$json.highPriorityItems}}\n\nPlease review the flagged content in the moderation dashboard.\n\nBest regards,\nContent Moderation System","subject":"Daily Content Moderation Report - {{$now.format('YYYY-MM-DD')}}","toEmail":"moderators@company.com","fromEmail":"content-moderation@company.com","options":{"allowUnauthorizedCerts":false}}}
2025-08-11T12:06:37.062Z [DEBUG] [MCP] Tool validate_node_minimal completed successfully
2025-08-11T12:06:40.088Z [INFO] [MCP] Calling tool: validate_node_minimal
2025-08-11T12:06:40.088Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.code","config":{"jsCode":"// Transform AI analysis results and social media post data for storage and reporting\nconst results = [];\n\nfor (const item of items) {\n  // Extract AI analysis results and post data\n  const postData = item.json.postData || item.json;\n  const aiAnalysis = item.json.aiAnalysis || item.json.analysis || {};\n  \n  // Determine if content should be flagged\n  const confidenceThreshold = 0.7;\n  const isInappropriate = aiAnalysis.inappropriateContent && \n    aiAnalysis.confidence >= confidenceThreshold;\n  \n  // Create structured record for database\n  const transformedRecord = {\n    // Post identification\n    postId: postData.id || postData.postId,\n    platform: postData.platform || 'unknown',\n    authorId: postData.author?.id || postData.authorId,\n    authorUsername: postData.author?.username || postData.username,\n    \n    // Content data\n    content: postData.text || postData.content,\n    contentType: postData.type || 'text',\n    mediaUrls: postData.media || [],\n    \n    // AI Analysis results\n    aiAnalysis: {\n      isInappropriate: isInappropriate,\n      confidence: aiAnalysis.confidence || 0,\n      categories: aiAnalysis.categories || [],\n      reasoning: aiAnalysis.reasoning || '',\n      toxicityScore: aiAnalysis.toxicityScore || 0,\n      sentimentScore: aiAnalysis.sentimentScore || 0\n    },\n    \n    // Moderation status\n    moderationStatus: isInappropriate ? 'flagged' : 'approved',\n    requiresReview: isInappropriate || aiAnalysis.confidence < 0.9,\n    \n    // Timestamps\n    postCreatedAt: postData.createdAt || postData.timestamp,\n    analyzedAt: new Date().toISOString(),\n    \n    // Metadata for reporting\n    metadata: {\n      processingTime: aiAnalysis.processingTime || 0,\n      modelVersion: aiAnalysis.modelVersion || 'v1.0',\n      batchId: item.json.batchId || null\n    }\n  };\n  \n  results.push({\n    json: transformedRecord\n  });\n}\n\nreturn results;","language":"javaScript"}}
2025-08-11T12:06:40.211Z [DEBUG] [MCP] Tool validate_node_minimal completed successfully
2025-08-11T12:06:40.211Z [INFO] [MCP] Calling tool: get_node_essentials
2025-08-11T12:06:40.211Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.scheduleTrigger"}
2025-08-11T12:06:40.389Z [DEBUG] [MCP] Tool get_node_essentials completed successfully
2025-08-11T12:06:44.036Z [INFO] [MCP] Calling tool: validate_node_minimal
2025-08-11T12:06:44.036Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.postgres","config":{"table":"content_moderation","columns":"post_id, platform, content_text, ai_analysis_score, is_flagged, flag_reason, analyzed_at, post_url, user_handle","operation":"insert","returnFields":"*"}}
2025-08-11T12:06:44.148Z [DEBUG] [MCP] Tool validate_node_minimal completed successfully
2025-08-11T12:06:44.149Z [INFO] [MCP] Calling tool: validate_node_minimal
2025-08-11T12:06:44.149Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.postgres","config":{"table":"content_moderation","columns":"post_id, platform, content_text, ai_analysis_score, is_flagged, flag_reason, analyzed_at, post_url, user_handle","operation":"insert","returnFields":"*"}}
2025-08-11T12:06:44.271Z [DEBUG] [MCP] Tool validate_node_minimal completed successfully
2025-08-11T12:06:44.272Z [INFO] [MCP] Calling tool: get_node_essentials
2025-08-11T12:06:44.272Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.if"}
2025-08-11T12:06:44.387Z [DEBUG] [MCP] Tool get_node_essentials completed successfully
2025-08-11T12:06:44.499Z [INFO] [MCP] Calling tool: validate_node_minimal
2025-08-11T12:06:44.499Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.scheduleTrigger","config":{"notice":""}}
2025-08-11T12:06:44.627Z [DEBUG] [MCP] Tool validate_node_minimal completed successfully
2025-08-11T12:06:44.627Z [INFO] [MCP] Calling tool: get_node_essentials
2025-08-11T12:06:44.627Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.twitter"}
2025-08-11T12:06:44.738Z [DEBUG] [MCP] Tool get_node_essentials completed successfully
2025-08-11T12:06:50.226Z [INFO] [MCP] Calling tool: validate_node_minimal
2025-08-11T12:06:50.226Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.if","config":{"conditions":{"conditions":[{"id":"1","leftValue":"={{ $json.analysis_result }}","rightValue":"inappropriate","operator":{"type":"string","operation":"equals"}},{"id":"2","leftValue":"={{ $json.confidence_score }}","rightValue":0.7,"operator":{"type":"number","operation":"gte"}}],"combineOperation":"all"}}}
2025-08-11T12:06:50.405Z [DEBUG] [MCP] Tool validate_node_minimal completed successfully
2025-08-11T12:06:50.427Z [INFO] [MCP] Calling tool: validate_node_minimal
2025-08-11T12:06:50.427Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.twitter","config":{"resource":"tweet","operation":"search","searchText":"#content OR #post OR from:verified -filter:retweets","returnAll":false,"limit":50}}
2025-08-11T12:06:50.550Z [DEBUG] [MCP] Tool validate_node_minimal completed successfully
2025-08-11T12:06:59.317Z [INFO] [MCP] Calling tool: validate_node_minimal
2025-08-11T12:06:59.318Z [DEBUG] [MCP] Parameters: {"nodeType":"nodes-base.code","config":{"jsCode":"// ⚠️ CRITICAL: Webhook data is nested under 'body' property!\n// Connect this Code node after a Webhook node receiving social media posts\n\n// Access webhook payload data - it's under .body, not directly under .json\nconst webhookData = items[0].json.body;  // ✅ CORRECT\nconst headers = items[0].json.headers;   // HTTP headers\nconst query = items[0].json.query;       // Query parameters\n\n// Process social media post data for content moderation\ntry {\n  // Validate required fields for social media posts\n  if (!webhookData.content && !webhookData.text && !webhookData.message) {\n    throw new Error('Missing required field: post content (content/text/message)');\n  }\n  \n  if (!webhookData.platform && !webhookData.source) {\n    throw new Error('Missing required field: social media platform');\n  }\n  \n  // Extract and normalize post content\n  const postContent = webhookData.content || webhookData.text || webhookData.message || '';\n  const platform = webhookData.platform || webhookData.source || 'unknown';\n  const postId = webhookData.id || webhookData.post_id || webhookData.postId || crypto.randomUUID();\n  const userId = webhookData.user_id || webhookData.userId || webhookData.author_id || 'unknown';\n  const username = webhookData.username || webhookData.author || webhookData.user || 'unknown';\n  const timestamp = webhookData.created_at || webhookData.timestamp || webhookData.posted_at || DateTime.now().toISO();\n  \n  // Extract media attachments if present\n  const mediaUrls = [];\n  if (webhookData.attachments) {\n    webhookData.attachments.forEach(attachment => {\n      if (attachment.type === 'image' || attachment.type === 'video') {\n        mediaUrls.push({\n          url: attachment.url,\n          type: attachment.type,\n          description: attachment.description || ''\n        });\n      }\n    });\n  }\n  \n  // Prepare structured data for AI analysis and moderation\n  const processedPost = {\n    // Core post data\n    postId: postId,\n    platform: platform.toLowerCase(),\n    content: postContent,\n    contentLength: postContent.length,\n    \n    // User information\n    user: {\n      id: userId,\n      username: username,\n      followerCount: webhookData.follower_count || 0\n    },\n    \n    // Timing\n    postedAt: timestamp,\n    processedAt: DateTime.now().toISO(),\n    \n    // Media attachments\n    hasMedia: mediaUrls.length > 0,\n    mediaCount: mediaUrls.length,\n    mediaUrls: mediaUrls,\n    \n    // Metadata for tracking\n    metadata: {\n      requestId: headers['x-request-id'] || crypto.randomUUID(),\n      webhookSource: query.source || 'social_media_webhook',\n      httpMethod: items[0].json.httpMethod,\n      webhookPath: items[0].json.webhookPath,\n      originalPayload: webhookData // Keep original for debugging\n    },\n    \n    // Moderation workflow flags\n    moderationStatus: 'pending',\n    flagged: false,\n    aiAnalysisRequired: true,\n    priority: postContent.length > 500 || mediaUrls.length > 0 ? 'high' : 'normal'\n  };\n  \n  // Add content analysis hints for AI\n  const analysisHints = {\n    hasUrls: /https?:\\/\\//i.test(postContent),\n    hasMentions: /@\\w+/g.test(postContent),\n    hasHashtags: /#\\w+/g.test(postContent),\n    wordCount: postContent.split(/\\s+/).length,\n    containsEmojis: /[\\u{1F600}-\\u{1F64F}]|[\\u{1F300}-\\u{1F5FF}]|[\\u{1F680}-\\u{1F6FF}]|[\\u{1F1E0}-\\u{1F1FF}]/gu.test(postContent)\n  };\n  \n  // Return processed data ready for AI analysis\n  return [{\n    json: {\n      ...processedPost,\n      analysisHints: analysisHints\n    }\n  }];\n  \n} catch (error) {\n  // Return error response for failed processing\n  return [{\n    json: {\n      status: 'processing_error',\n      error: error.message,\n      timestamp: DateTime.now().toISO(),\n      originalData: webhookData,\n      metadata: {\n        requestId: headers['x-request-id'] || crypto.randomUUID(),\n        source: 'social_media_webhook_error'\n      }\n    }\n  }];\n}","language":"javaScript"}}
2025-08-11T12:06:59.505Z [DEBUG] [MCP] Tool validate_node_minimal completed successfully
2025-08-11T12:07:01.863Z [INFO] [Tools] Added node: nodes-base.code (Transform data structure using JavaScript)
2025-08-11T12:07:01.863Z [INFO] [Tools] Added node: nodes-base.openAi (Send a message to an AI model and get response)
2025-08-11T12:07:01.863Z [INFO] [Tools] Added node: nodes-base.emailSend (Send an email notification)
2025-08-11T12:07:01.863Z [INFO] [Tools] Added node: nodes-base.code (Process incoming webhook data with Code node (shows correct data access))
2025-08-11T12:07:01.863Z [INFO] [Tools] Added node: nodes-base.postgres (Insert data into PostgreSQL table)
2025-08-11T12:07:01.863Z [WARN] [Orchestrator] Node task_node_3: Missing required field: Schema
2025-08-11T12:07:01.863Z [INFO] [Tools] Added node: nodes-base.scheduleTrigger (Triggers daily execution for digest email generation)
2025-08-11T12:07:01.863Z [INFO] [Tools] Added node: nodes-base.if (Routes content based on AI analysis results for conditional flagging)
2025-08-11T12:07:01.863Z [INFO] [Tools] Added node: nodes-base.twitter (Monitors social media posts as trigger source for content analysis)
2025-08-11T12:07:01.955Z [DEBUG] [Orchestrator] Session state updated
2025-08-11T12:07:01.955Z [INFO] [Orchestrator] Data flow captured: 3 transformations
```

### Nodes
- **nodes-base.code** (ID: task_node_4)
  - Purpose: Transform data structure using JavaScript
  - Validation: valid
- **nodes-base.openAi** (ID: task_node_2)
  - Purpose: Send a message to an AI model and get response
  - Validation: valid
- **nodes-base.emailSend** (ID: task_node_5)
  - Purpose: Send an email notification
  - Validation: valid
- **nodes-base.code** (ID: task_node_1)
  - Purpose: Process incoming webhook data with Code node (shows correct data access)
  - Validation: valid
- **nodes-base.postgres** (ID: task_node_3)
  - Purpose: Insert data into PostgreSQL table
  - Validation: invalid
  - Errors: Missing required field: Schema
- **nodes-base.scheduleTrigger** (ID: search_node_1)
  - Purpose: Triggers daily execution for digest email generation
  - Validation: valid
- **nodes-base.if** (ID: search_node_2)
  - Purpose: Routes content based on AI analysis results for conditional flagging
  - Validation: valid
- **nodes-base.twitter** (ID: search_node_3)
  - Purpose: Monitors social media posts as trigger source for content analysis
  - Validation: valid

### Errors
1. **validation**: 1 nodes failed validation

### Warnings
1. Node task_node_3: Missing required field: Schema

### Data Flow
**Input:**
```json
{
  "discoveredNodes": [
    {
      "id": "task_node_4",
      "type": "nodes-base.code",
      "displayName": "transform data",
      "purpose": "Transform data structure using JavaScript",
      "isPreConfigured": true,
      "config": {
        "language": "javaScript",
        "jsCode": "// Transform each item\nconst results = [];\n\nfor (const item of items) {\n  results.push({\n    json: {\n      // Transform your data here\n      id: item.json.id,\n      processedAt: new Date().toISOString()\n    }\n  });\n}\n\nreturn results;"
      }
    },
    {
      "id": "task_node_2",
      "type": "nodes-base.openAi",
      "displayName": "chat with ai",
      "purpose": "Send a message to an AI model and get response",
      "isPreConfigured": true,
      "config": {
        "resource": "chat",
        "operation": "message",
        "modelId": "gpt-3.5-turbo",
        "messages": {
          "values": [
            {
              "role": "user",
              "content": ""
            }
          ]
        },
        "onError": "continueRegularOutput",
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 5000,
        "alwaysOutputData": true
      }
    },
    {
      "id": "task_node_5",
      "type": "nodes-base.emailSend",
      "displayName": "send email",
      "purpose": "Send an email notification",
      "isPreConfigured": true,
      "config": {
        "fromEmail": "",
        "toEmail": "",
        "subject": "",
        "text": "",
        "onError": "continueRegularOutput",
        "retryOnFail": true,
        "maxTries": 3,
        "waitBetweenTries": 3000,
        "alwaysOutputData": true
      }
    },
    {
      "id": "task_node_1",
      "type": "nodes-base.code",
      "displayName": "process webhook data",
      "purpose": "Process incoming webhook data with Code node (shows correct data access)",
      "isPreConfigured": true,
      "config": {
        "language": "javaScript",
        "jsCode": "// ⚠️ CRITICAL: Webhook data is nested under 'body' property!\n// Connect this Code node after a Webhook node\n\n// Access webhook payload data - it's under .body, not directly under .json\nconst webhookData = items[0].json.body;  // ✅ CORRECT\nconst headers = items[0].json.headers;   // HTTP headers\nconst query = items[0].json.query;       // Query parameters\n\n// Common mistake to avoid:\n// const command = items[0].json.testCommand;  // ❌ WRONG - will be undefined!\n// const command = items[0].json.body.testCommand;  // ✅ CORRECT\n\n// Process the webhook data\ntry {\n  // Validate required fields\n  if (!webhookData.command) {\n    throw new Error('Missing required field: command');\n  }\n  \n  // Process based on command\n  let result = {};\n  switch (webhookData.command) {\n    case 'process':\n      result = {\n        status: 'processed',\n        data: webhookData.data,\n        processedAt: DateTime.now().toISO()\n      };\n      break;\n      \n    case 'validate':\n      result = {\n        status: 'validated',\n        isValid: true,\n        validatedFields: Object.keys(webhookData.data || {})\n      };\n      break;\n      \n    default:\n      result = {\n        status: 'unknown_command',\n        command: webhookData.command\n      };\n  }\n  \n  // Return processed data\n  return [{\n    json: {\n      ...result,\n      requestId: headers['x-request-id'] || crypto.randomUUID(),\n      source: query.source || 'webhook',\n      originalCommand: webhookData.command,\n      metadata: {\n        httpMethod: items[0].json.httpMethod,\n        webhookPath: items[0].json.webhookPath,\n        timestamp: DateTime.now().toISO()\n      }\n    }\n  }];\n  \n} catch (error) {\n  // Return error response\n  return [{\n    json: {\n      status: 'error',\n      error: error.message,\n      timestamp: DateTime.now().toISO()\n    }\n  }];\n}",
        "onError": "continueRegularOutput"
      }
    },
    {
      "id": "task_node_3",
      "type": "nodes-base.postgres",
      "displayName": "insert postgres data",
      "purpose": "Insert data into PostgreSQL table",
      "isPreConfigured": true,
      "config": {
        "operation": "insert",
        "table": "",
        "columns": "",
        "returnFields": "*",
        "onError": "stopWorkflow",
        "retryOnFail": true,
        "maxTries": 2,
        "waitBetweenTries": 1000
      }
    },
    {
      "id": "search_node_1",
      "type": "nodes-base.scheduleTrigger",
      "displayName": "nodes-base.scheduleTrigger",
      "purpose": "Triggers daily execution for digest email generation",
      "needsConfiguration": true
    },
    {
      "id": "search_node_2",
      "type": "nodes-base.if",
      "displayName": "nodes-base.if",
      "purpose": "Routes content based on AI analysis results for conditional flagging",
      "needsConfiguration": true
    },
    {
      "id": "search_node_3",
      "type": "nodes-base.twitter",
      "displayName": "nodes-base.twitter",
      "purpose": "Monitors social media posts as trigger source for content analysis",
      "needsConfiguration": true
    }
  ]
}
```

**Output:**
```json
{
  "configuredNodes": [
    {
      "id": "task_node_4",
      "type": "nodes-base.code",
      "purpose": "Transform data structure using JavaScript",
      "config": {
        "typeVersion": 2,
        "notes": "Transform AI analysis results and social media post data into structured format for database storage and reporting. Combines content analysis flags, confidence scores, and post metadata into normalized records.",
        "parameters": {
          "jsCode": "// Transform AI analysis results and social media post data for storage and reporting\nconst results = [];\n\nfor (const item of items) {\n  // Extract AI analysis results and post data\n  const postData = item.json.postData || item.json;\n  const aiAnalysis = item.json.aiAnalysis || item.json.analysis || {};\n  \n  // Determine if content should be flagged\n  const confidenceThreshold = 0.7;\n  const isInappropriate = aiAnalysis.inappropriateContent && \n    aiAnalysis.confidence >= confidenceThreshold;\n  \n  // Create structured record for database\n  const transformedRecord = {\n    // Post identification\n    postId: postData.id || postData.postId,\n    platform: postData.platform || 'unknown',\n    authorId: postData.author?.id || postData.authorId,\n    authorUsername: postData.author?.username || postData.username,\n    \n    // Content data\n    content: postData.text || postData.content,\n    contentType: postData.type || 'text',\n    mediaUrls: postData.media || [],\n    \n    // AI Analysis results\n    aiAnalysis: {\n      isInappropriate: isInappropriate,\n      confidence: aiAnalysis.confidence || 0,\n      categories: aiAnalysis.categories || [],\n      reasoning: aiAnalysis.reasoning || '',\n      toxicityScore: aiAnalysis.toxicityScore || 0,\n      sentimentScore: aiAnalysis.sentimentScore || 0\n    },\n    \n    // Moderation status\n    moderationStatus: isInappropriate ? 'flagged' : 'approved',\n    requiresReview: isInappropriate || aiAnalysis.confidence < 0.9,\n    \n    // Timestamps\n    postCreatedAt: postData.createdAt || postData.timestamp,\n    analyzedAt: new Date().toISOString(),\n    \n    // Metadata for reporting\n    metadata: {\n      processingTime: aiAnalysis.processingTime || 0,\n      modelVersion: aiAnalysis.modelVersion || 'v1.0',\n      batchId: item.json.batchId || null\n    }\n  };\n  \n  results.push({\n    json: transformedRecord\n  });\n}\n\nreturn results;",
          "language": "javaScript"
        }
      },
      "validated": true
    },
    {
      "id": "task_node_2",
      "type": "nodes-base.openAi",
      "purpose": "Send a message to an AI model and get response",
      "config": {
        "onError": "continueRegularOutput",
        "maxTries": 3,
        "retryOnFail": true,
        "alwaysOutputData": true,
        "waitBetweenTries": 5000,
        "typeVersion": 1,
        "notes": "AI content moderation - analyzes social media posts for inappropriate material and flags suspicious content",
        "parameters": {
          "modelId": "gpt-4",
          "messages": {
            "values": [
              {
                "role": "system",
                "content": "You are a content moderation AI. Analyze social media posts for inappropriate content including hate speech, harassment, spam, adult content, violence, and misinformation. Respond with a JSON object containing: {\"flagged\": boolean, \"confidence\": number (0-1), \"categories\": [array of violation types], \"severity\": \"low\"|\"medium\"|\"high\", \"summary\": \"brief explanation\"}"
              },
              {
                "role": "user",
                "content": "Please analyze this social media post for inappropriate content:\n\nPost Content: {{$json.content}}\nAuthor: {{$json.author}}\nPlatform: {{$json.platform}}\nPost ID: {{$json.post_id}}"
              }
            ]
          },
          "resource": "chat",
          "operation": "message",
          "options": {
            "temperature": 0.1,
            "maxTokens": 500
          }
        }
      },
      "validated": true
    },
    {
      "id": "task_node_5",
      "type": "nodes-base.emailSend",
      "purpose": "Send an email notification",
      "config": {
        "onError": "continueRegularOutput",
        "maxTries": 3,
        "retryOnFail": true,
        "alwaysOutputData": true,
        "waitBetweenTries": 3000,
        "typeVersion": 2,
        "notes": "Send daily digest email to moderators with content moderation statistics and flagged items summary",
        "parameters": {
          "text": "Daily Content Moderation Summary\n\nDate: {{$now.format('YYYY-MM-DD')}}\n\nStatistics:\n- Total posts analyzed: {{$json.totalPosts}}\n- Flagged items: {{$json.flaggedCount}}\n- Approval rate: {{$json.approvalRate}}%\n\nFlagged Content Summary:\n{{$json.flaggedItemsSummary}}\n\nHigh Priority Items:\n{{$json.highPriorityItems}}\n\nPlease review the flagged content in the moderation dashboard.\n\nBest regards,\nContent Moderation System",
          "subject": "Daily Content Moderation Report - {{$now.format('YYYY-MM-DD')}}",
          "toEmail": "moderators@company.com",
          "fromEmail": "content-moderation@company.com",
          "options": {
            "allowUnauthorizedCerts": false
          }
        }
      },
      "validated": true
    },
    {
      "id": "task_node_1",
      "type": "nodes-base.code",
      "purpose": "Process incoming webhook data with Code node (shows correct data access)",
      "config": {
        "onError": "continueRegularOutput",
        "notes": "Process incoming social media posts from webhook, extract content for AI analysis, and prepare data structure for content moderation workflow",
        "parameters": {
          "jsCode": "// ⚠️ CRITICAL: Webhook data is nested under 'body' property!\n// Connect this Code node after a Webhook node receiving social media posts\n\n// Access webhook payload data - it's under .body, not directly under .json\nconst webhookData = items[0].json.body;  // ✅ CORRECT\nconst headers = items[0].json.headers;   // HTTP headers\nconst query = items[0].json.query;       // Query parameters\n\n// Process social media post data for content moderation\ntry {\n  // Validate required fields for social media posts\n  if (!webhookData.content && !webhookData.text && !webhookData.message) {\n    throw new Error('Missing required field: post content (content/text/message)');\n  }\n  \n  if (!webhookData.platform && !webhookData.source) {\n    throw new Error('Missing required field: social media platform');\n  }\n  \n  // Extract and normalize post content\n  const postContent = webhookData.content || webhookData.text || webhookData.message || '';\n  const platform = webhookData.platform || webhookData.source || 'unknown';\n  const postId = webhookData.id || webhookData.post_id || webhookData.postId || crypto.randomUUID();\n  const userId = webhookData.user_id || webhookData.userId || webhookData.author_id || 'unknown';\n  const username = webhookData.username || webhookData.author || webhookData.user || 'unknown';\n  const timestamp = webhookData.created_at || webhookData.timestamp || webhookData.posted_at || DateTime.now().toISO();\n  \n  // Extract media attachments if present\n  const mediaUrls = [];\n  if (webhookData.attachments) {\n    webhookData.attachments.forEach(attachment => {\n      if (attachment.type === 'image' || attachment.type === 'video') {\n        mediaUrls.push({\n          url: attachment.url,\n          type: attachment.type,\n          description: attachment.description || ''\n        });\n      }\n    });\n  }\n  \n  // Prepare structured data for AI analysis and moderation\n  const processedPost = {\n    // Core post data\n    postId: postId,\n    platform: platform.toLowerCase(),\n    content: postContent,\n    contentLength: postContent.length,\n    \n    // User information\n    user: {\n      id: userId,\n      username: username,\n      followerCount: webhookData.follower_count || 0\n    },\n    \n    // Timing\n    postedAt: timestamp,\n    processedAt: DateTime.now().toISO(),\n    \n    // Media attachments\n    hasMedia: mediaUrls.length > 0,\n    mediaCount: mediaUrls.length,\n    mediaUrls: mediaUrls,\n    \n    // Metadata for tracking\n    metadata: {\n      requestId: headers['x-request-id'] || crypto.randomUUID(),\n      webhookSource: query.source || 'social_media_webhook',\n      httpMethod: items[0].json.httpMethod,\n      webhookPath: items[0].json.webhookPath,\n      originalPayload: webhookData // Keep original for debugging\n    },\n    \n    // Moderation workflow flags\n    moderationStatus: 'pending',\n    flagged: false,\n    aiAnalysisRequired: true,\n    priority: postContent.length > 500 || mediaUrls.length > 0 ? 'high' : 'normal'\n  };\n  \n  // Add content analysis hints for AI\n  const analysisHints = {\n    hasUrls: /https?:\\/\\//i.test(postContent),\n    hasMentions: /@\\w+/g.test(postContent),\n    hasHashtags: /#\\w+/g.test(postContent),\n    wordCount: postContent.split(/\\s+/).length,\n    containsEmojis: /[\\u{1F600}-\\u{1F64F}]|[\\u{1F300}-\\u{1F5FF}]|[\\u{1F680}-\\u{1F6FF}]|[\\u{1F1E0}-\\u{1F1FF}]/gu.test(postContent)\n  };\n  \n  // Return processed data ready for AI analysis\n  return [{\n    json: {\n      ...processedPost,\n      analysisHints: analysisHints\n    }\n  }];\n  \n} catch (error) {\n  // Return error response for failed processing\n  return [{\n    json: {\n      status: 'processing_error',\n      error: error.message,\n      timestamp: DateTime.now().toISO(),\n      originalData: webhookData,\n      metadata: {\n        requestId: headers['x-request-id'] || crypto.randomUUID(),\n        source: 'social_media_webhook_error'\n      }\n    }\n  }];\n}",
          "language": "javaScript"
        }
      },
      "validated": true
    },
    {
      "id": "task_node_3",
      "type": "nodes-base.postgres",
      "purpose": "Insert data into PostgreSQL table",
      "config": {
        "onError": "stopWorkflow",
        "maxTries": 2,
        "retryOnFail": true,
        "waitBetweenTries": 1000,
        "typeVersion": 2.4,
        "notes": "Insert AI content analysis results into PostgreSQL database - stores flagged content, analysis scores, and metadata for moderation workflow",
        "parameters": {
          "table": "content_moderation",
          "columns": "post_id, platform, content_text, ai_analysis_score, is_flagged, flag_reason, analyzed_at, post_url, user_handle",
          "operation": "insert",
          "returnFields": "*"
        }
      },
      "validated": false,
      "validationErrors": [
        "Missing required field: Schema"
      ]
    },
    {
      "id": "search_node_1",
      "type": "nodes-base.scheduleTrigger",
      "purpose": "Triggers daily execution for digest email generation",
      "config": {
        "typeVersion": 1.2,
        "notes": "Triggers daily execution for generating and sending digest emails to moderators",
        "parameters": {
          "notice": ""
        }
      },
      "validated": true
    },
    {
      "id": "search_node_2",
      "type": "nodes-base.if",
      "purpose": "Routes content based on AI analysis results for conditional flagging",
      "config": {
        "typeVersion": 2.2,
        "notes": "Routes social media posts based on AI analysis results to flag inappropriate content",
        "parameters": {
          "conditions": {
            "conditions": [
              {
                "id": "1",
                "leftValue": "={{ $json.analysis_result }}",
                "rightValue": "inappropriate",
                "operator": {
                  "type": "string",
                  "operation": "equals"
                }
              },
              {
                "id": "2",
                "leftValue": "={{ $json.confidence_score }}",
                "rightValue": 0.7,
                "operator": {
                  "type": "number",
                  "operation": "gte"
                }
              }
            ],
            "combineOperation": "all"
          }
        }
      },
      "validated": true
    },
    {
      "id": "search_node_3",
      "type": "nodes-base.twitter",
      "purpose": "Monitors social media posts as trigger source for content analysis",
      "config": {
        "typeVersion": 2,
        "notes": "Monitors Twitter for new posts to trigger content moderation workflow",
        "parameters": {
          "resource": "tweet",
          "operation": "search",
          "searchText": "#content OR #post OR from:verified -filter:retweets",
          "returnAll": false,
          "limit": 50
        }
      },
      "validated": true
    }
  ]
}
```

**Transformations:**
- Parameter Configuration
- Validation
- Type Checking

### Session State Changes
**Changed from discovery phase:**

**Modified:**
- `state`: {11 fields} → {11 fields}

**Unchanged (2 fields):** sessionId, createdAt

## ========== BUILDING PHASE ==========

**Status:** ❌ Failed
**Duration:** 0ms

### Logs
```
```

## ========== VALIDATION PHASE ==========

**Status:** ❌ Failed
**Duration:** 0ms

### Logs
```
```

## ========== DOCUMENTATION PHASE ==========

**Status:** ❌ Failed
**Duration:** 0ms

### Logs
```
```

## Summary

### Metrics
- **Total Nodes:** 0
- **Total Connections:** 0
- **Validation Attempts:** 0
- **Errors Fixed:** 0
- **Sticky Notes Added:** 0

### Scores
- **Performance Score:** 20/100
- **Quality Score:** 100/100
- **Completeness Score:** 20/100

### Error Patterns
- **validation** (1 occurrences)
  - Suggested Fix: Review error details and adjust workflow accordingly

### Optimization Suggestions
- Consider optimizing discovery phase (took 23774ms)
- Consider optimizing configuration phase (took 36181ms)
